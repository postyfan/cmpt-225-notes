1. [ ] Implement the class BST with all its operations. We saw the pseudo-code, but it is not implemented in the code.

2. [ ] Create a BST by inserting the elements [6, 1, 4, 7, 5, 8, 2, 3, 9]. Then, remove 8 and 4 from the obtained tree.

3. [ ] Write an algorithm that gets a BST and returns the minimal element.

4. [ ] Write an algorithm that gets a BST and returns the maximal element.

5. [ ] Write an algorithm that converts a BST into a sorted linked list with the same values.

6. [ ] Write an algorithm that given a BST and a number k, outputs all values in the tree that are smaller than k. Write it as efficiently as possible, the running time should be O(length of the output)

7. [ ] Write an algorithm that given a BST and two numbers, outputs all values in the tree between those numbers.

8. [ ] Write an algorithm that gets a sequence of numbers and decides whether it is a PostOrder traversal of some BST.

9. [ ] Write an algorithm that gets a PostOrder traversal of a BST, and returns the tree. Prove that such BST is unique.

10. [ ] Write an algorithms that gets a BST and a number t, and returns a node in the tree that contains the largest value that is smaller that t.

11. [ ] Modify the class BST to support the following operations with the following running times:
    - insert() - O(depth of the tree)
    - delete() - O(depth of the tree) - deletes 
    - find() - O(depth of the tree)
    - get_size(BTNode node) - O(1) - returns the size of the subtree under the given node.

12. [ ] How many distinct BSTs can be created with values?

13. [ ] **How many distinct BSTs can be created with values?

14. [ ] **How many distinct BSTs of height can be created with values?

15. [ ] Write an algorithm that outputs all permutations of the numbers, such that when creating a BST from these sequences, we get trees of height.